#Coding: Expertise in at least one programming language is required. Know a fair amount of detail about your favorite programming 

language. You will be expected to know about API’s, OOD/OOP, and how to test code (including both corner and edge cases).

● We expect variable declaration/initialization, error checking, and effective use of appropriate data structures. Coding exercises may require synchronization primitives and concurrency libraries. Make sure your code is clean and bug-free, and avoid writing pseudo-code unless directed to do so.

● We focus on conceptual understanding rather than memorization. We are not looking for memorization of all Java APIs (or the equivalents in other languages). It’s fine if you forget a method or a class name.

● Some interviewers care more about syntax than others - if you’re not sure, ask. 

#Algorithms: You will likely be asked to design an algorithm and write code. You will be expected to know the complexity of an algorithm and how you can improve/change it. Be comfortable with big-O analysis and running time complexity. Be prepared to explain the running- time complexity of algorithms you know and are asked to devise.

● When writing a more complicated algorithm, make sure you have a solid idea in your head (or outlined in bullet points) and discuss the algorithm you have in mind before jumping into coding.

● Know about the most famous classes of NP-complete problems, such as traveling salesman and the knapsack problem. Be able to recognize different variations of these common problems.

● Review dynamic programming and know when to use it. 

● Be ready to discuss complex algorithms such as Dijkstra and A*. 

Data structures: Know when and how to use all of the common data structures. You will also need to know about Trees (including basic tree construction), traversal and manipulation algorithms, hash tables, stacks, arrays, linked lists, priority queues. Note: Assume you don’t have to implement them if your language’s standard library ships them for you.

Sorting: What common sorting functions are there? On what kind of input data are they efficient, when are they not? What does efficiency mean in these cases in terms of runtime and space used? E.g. in exceptional cases insertion-sort or radix-sort are much better than the generic QuickSort / MergeSort / HeapSort answers. You should know the details of at least one n*log(n) sorting algorithm, preferably two (say, quick sort and merge sort).

Searching: Familiarize yourself with some common search algorithms. This could be anything from simple binary search, over depth- first/breadth-first tree search, combinatorial search over solution spaces, substring searching, etc.

Mathematics: Counting problems, probability problems, and other Discrete Math 101 situations surrounds us here at Google. Spend some time before the interview refreshing your memory on (or teaching yourself) the essentials of elementary probability theory and combinatorics. You should be familiar with n-choose-k problems and their ilk – the more the better.

Graphs: To consider a problem as a graph is often a very good abstraction to apply, since well known graph algorithms for distance, search, connectivity, cycle-detection etc. will then yield a solution to the original problem. There are 3 basic ways to represent a graph in memory (objects and pointers, matrix, and adjacency list); familiarize yourself with each representation and its pros/cons. You should know the basic graph traversal algorithms, breadth-first search and depth-first search. Know their computational complexity, their tradeoffs, and how to implement them in real code.

Recursion: Many coding problems involve thinking recursively and potentially coding a recursive solution. Prepare for recursion, which can sometimes be tricky if not approached properly. Practice some problems that can be solved iteratively, but a more elegant solution involves recursion.

Operating systems: Be prepared to answer questions on concurrent processing and distributed systems. You should understand processes, threads, concurrency issues, locks, mutexes, semaphores, monitors and how they all work. Understand deadlock, livelock and how to avoid them. Understand how context switching works, how it's initiated by the operating system and underlying hardware. Know a little about scheduling. Know the fundamentals of "modern" concurrency constructs.

System design: Questions about system design or component design are common. They are typically formulated so that they are approachable to any person with a computer science background and some work experience. Sample topics include: features sets, interfaces, class hierarchies, distributed systems, designing a system under certain constraints, simplicity, limitations, robustness and tradeoffs. You should also have an understanding of how the Internet actually works and be familiar with the various pieces (routers, domain name servers, load balancers, firewalls, etc.).

● Note: University Graduate candidates without industry experience are not typically asked system design questions.